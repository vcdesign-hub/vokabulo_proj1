---
import BaseLayout from '../../layouts/BaseLayout.astro';
import { SUPPORTED_LANGS, DEFAULT_LANG, isValidLanguage } from '../../utils/i18n';
import { generateFallbackDescription } from '../../utils/seo';
import { readFileSync, existsSync } from 'fs';
import { join } from 'path';
import { marked } from 'marked';

export function getStaticPaths() {
  return SUPPORTED_LANGS.map(lang => ({
    params: { lang }
  }));
}

const { lang } = Astro.params;

if (!isValidLanguage(lang)) {
  return Astro.redirect(`/${DEFAULT_LANG}/support`);
}

function slugify(input: string): string {
  return input
    .toLowerCase()
    .trim()
    .replace(/[^\p{L}\p{N}\s-]/gu, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-');
}

// Load markdown content
const contentPath = join(process.cwd(), 'content', 'pages', lang, 'support.md');
let rawMarkdown = '';
let title = 'Support · Vokabulo';
let description = '';
type SupportSection = { id: string; title: string; items: { id: string; title: string }[]; markdown: string };
let sections: SupportSection[] = [];

if (existsSync(contentPath)) {
  const fileContent = readFileSync(contentPath, 'utf-8');
  // Extract frontmatter
  const frontmatterMatch = fileContent.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
  if (frontmatterMatch) {
    const frontmatter = frontmatterMatch[1];
    rawMarkdown = frontmatterMatch[2];
    const titleMatch = frontmatter.match(/title:\s*["'](.*)["']/);
    if (titleMatch) title = titleMatch[1];
    const descMatch = frontmatter.match(/description:\s*["'](.*)["']/);
    if (descMatch) description = descMatch[1];
  } else {
    rawMarkdown = fileContent;
  }
  
  // Generate fallback description if not in frontmatter
  if (!description && rawMarkdown) {
    description = generateFallbackDescription(rawMarkdown, 160);
  }
}

// Split markdown into H2 sections while keeping the page as one continuous document.
// H2 (##) => sidebar section, H3 (###) => subsection link under that section.
(() => {
  const lines = rawMarkdown.split('\n');
  let current: SupportSection | null = null;
  let buffer: string[] = [];

  const flush = () => {
    if (!current) return;
    current.markdown = buffer.join('\n').trim() + '\n';
    sections.push(current);
  };

  for (const line of lines) {
    const h2 = line.match(/^##\s+(.*)\s*$/);
    if (h2) {
      flush();
      const h2Title = h2[1].trim();
      const h2Id = slugify(h2Title);
      current = { id: h2Id, title: h2Title, items: [], markdown: '' };
      buffer = [line];
      continue;
    }

    const h3 = line.match(/^###\s+(.*)\s*$/);
    if (h3 && current) {
      const h3Title = h3[1].trim();
      const h3Id = slugify(h3Title);
      current.items.push({ id: h3Id, title: h3Title });
    }

    buffer.push(line);
  }

  flush();
})();

// Render markdown with stable heading ids (needed for anchor nav)
// Note: marked v17 passes a token object to renderer.heading().
const renderer = new marked.Renderer();
// eslint-disable-next-line @typescript-eslint/no-explicit-any
renderer.heading = (...args: any[]) => {
  // marked v17: heading(token)
  if (args.length === 1 && typeof args[0] === 'object' && args[0]) {
    const token = args[0];
    const level = token.depth ?? token.level ?? token.depthLevel ?? 0;
    const text = String(token.text ?? '');
    if (level === 2 || level === 3) {
      const id = slugify(text);
      return `<h${level} id="${id}">${text}</h${level}>`;
    }
    return `<h${level}>${text}</h${level}>`;
  }

  // older marked: heading(text, level, raw)
  const [text, level, raw] = args;
  const headingText = String(text ?? '');
  const headingLevel = Number(level ?? 0);
  if (headingLevel === 2 || headingLevel === 3) {
    const id = slugify(String(raw ?? headingText));
    return `<h${headingLevel} id="${id}">${headingText}</h${headingLevel}>`;
  }
  return `<h${headingLevel}>${headingText}</h${headingLevel}>`;
};
---

<BaseLayout title={title} description={description} currentLang={lang} currentPath="/support">
  <!-- Mobile sticky nav (fixed to viewport, outside main content) -->
  <details class="help-nav-mobile">
    <summary>On this page</summary>
    <nav aria-label="Support navigation (mobile)">
      <ul class="help-nav-items">
        {sections.map((s) => (
          <li><a href={`#${s.id}`}>{s.title}</a></li>
        ))}
      </ul>
    </nav>
  </details>

  <!-- Floating button nav for very small screens -->
  <details class="help-nav-fab">
    <summary>
      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
        <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16" />
      </svg>
      On this page
    </summary>
    <div class="help-nav-fab-panel">
      <nav aria-label="Support navigation (floating)">
        <div class="help-nav-search">
          <input type="search" id="help-search-fab" placeholder="Search..." aria-label="Search help articles" />
          <button class="help-nav-search-clear" id="help-search-fab-clear" aria-label="Clear search" type="button">×</button>
        </div>
        <ul class="help-nav-items">
          {sections.map((s) => (
            <li><a href={`#${s.id}`}>{s.title}</a></li>
          ))}
        </ul>
      </nav>
    </div>
  </details>

  <style is:global>
    /* Support page-specific styles */
    :root {
      --accent: #0ea5e9;
    }

    .page {
      max-width: 1100px;
      margin: 0 auto;
      /* Match homepage horizontal padding: px-4 (16px) / md:px-6 (24px) */
      padding: 0 16px 48px;
    }

    main {
      padding-top: 140px;
    }
    
    @media (min-width: 768px) {
      .page {
        padding-left: 24px;
        padding-right: 24px;
      }
    }

    h1 {
      margin: 0 0 24px;
      font-size: 40px;
      font-weight: 700;
      line-height: 1.2;
      letter-spacing: -0.02em;
    }

    h2 {
      margin: 48px 0 16px;
      font-size: 28px;
      font-weight: 700;
      line-height: 1.3;
      color: var(--ink);
      letter-spacing: -0.01em;
      padding-top: 20px;
      border-top: 1px solid var(--border);
    }

    h2:first-of-type {
      margin-top: 0;
      padding-top: 0;
      border-top: none;
    }

    h3 {
      margin: 40px 0 16px;
      font-size: 20px;
      font-weight: 600;
      line-height: 1.4;
      color: var(--ink);
      letter-spacing: -0.01em;
      scroll-margin-top: 100px;
    }

    p {
      margin: 0 0 20px;
      color: var(--muted);
      line-height: 1.7;
      font-size: 18px;
    }

    /* Only apply list typography spacing to the article content.
       The left nav also uses <ul>/<li>, and we don't want big gaps there. */
    .help-article ul {
      list-style: disc;
      padding-left: 24px;
      margin: 0 0 20px;
      color: var(--muted);
      line-height: 1.7;
      font-size: 18px;
    }

    .help-article ol {
      list-style: decimal;
      padding-left: 24px;
      margin: 0 0 20px;
      color: var(--muted);
      line-height: 1.7;
      font-size: 18px;
    }

    .help-article li {
      margin: 6px 0;
    }

    /* Some markdown renderers wrap list-item text in <p>, which adds extra gaps */
    .help-article li > p {
      margin: 0;
    }

    /* Nested lists */
    .help-article ul ul,
    .help-article ol ol,
    .help-article ul ol,
    .help-article ol ul {
      margin-top: 8px;
      margin-bottom: 0;
    }

    .help-article ul li strong {
      color: var(--ink);
      font-weight: 600;
    }

    strong {
      color: var(--ink);
      font-weight: 600;
    }

    hr {
      border: none;
      border-top: 1px solid var(--border);
      margin: 32px 0;
    }

    /* Support page (Notion-like) layout (from original support.html) */
    .help-layout {
      display: grid;
      grid-template-columns: 1fr;
      gap: 22px;
    }

    @media (min-width: 768px) {
      .help-layout {
        grid-template-columns: 280px 1fr;
        gap: 28px;
      }
    }

    .help-nav {
      display: none;
    }

    @media (min-width: 768px) {
      .help-nav {
        display: flex;
        flex-direction: column;
        position: sticky;
        top: 120px;
        align-self: start;
        border-right: 1px solid var(--border);
        padding-right: 18px;
        margin-right: 6px;
        max-height: calc(100vh - 140px);
        overflow-y: auto;
      }
    }

    .help-nav-search {
      margin-bottom: 16px;
      position: relative;
    }

    .help-nav-search input {
      width: 100%;
      padding: 8px 32px 8px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #ffffff;
      color: var(--ink);
      font-size: 14px;
      transition: border-color 150ms ease, box-shadow 150ms ease;
    }

    /* Hide browser-provided clear (x) on <input type="search"> to avoid double clear controls */
    .help-nav-search input[type='search']::-webkit-search-cancel-button,
    .help-nav-search input[type='search']::-webkit-search-decoration {
      -webkit-appearance: none;
      appearance: none;
      display: none;
    }

    .help-nav-search input[type='search']::-ms-clear {
      display: none;
      width: 0;
      height: 0;
    }

    .help-nav-search input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);
    }

    .help-nav-search-clear {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: var(--muted);
      font-size: 18px;
      cursor: pointer;
      padding: 4px 6px;
      line-height: 1;
      opacity: 0;
      pointer-events: none;
      transition: opacity 150ms ease, color 150ms ease;
    }

    .help-nav-search-clear.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .help-nav-search-clear:hover {
      color: var(--ink);
    }

    .help-nav-section.hidden-by-search,
    .help-nav-items li.hidden-by-search {
      display: none;
    }

    .help-nav-items li.highlight-match a {
      color: var(--accent);
      font-weight: 600;
    }

    .help-nav-content {
      flex: 1;
      overflow-y: auto;
      padding-right: 4px;
    }

    .help-nav-content::-webkit-scrollbar {
      width: 6px;
    }

    .help-nav-content::-webkit-scrollbar-track {
      background: transparent;
    }

    .help-nav-content::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 3px;
    }

    .help-nav-content::-webkit-scrollbar-thumb:hover {
      background: var(--muted);
    }

    .help-nav-section {
      margin: 0 0 16px;
    }

    .help-nav-section-header {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      user-select: none;
    }

    .help-nav-section-header a {
      flex: 1;
      display: block;
      padding: 6px 10px;
      border-radius: 12px;
      font-weight: 700;
      font-size: 18px;
      color: var(--ink);
      text-decoration: none;
    }

    .help-nav-section-header:hover a {
      background: rgba(15, 23, 42, 0.06);
    }

    .help-nav-toggle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      padding: 0;
      border: none;
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      transition: transform 200ms ease, color 150ms ease;
      flex-shrink: 0;
      border-radius: 4px;
    }

    .help-nav-toggle:hover {
      color: var(--ink);
      background: rgba(15, 23, 42, 0.06);
    }

    .help-nav-toggle svg {
      width: 14px;
      height: 14px;
    }

    .help-nav-section.expanded .help-nav-toggle {
      transform: rotate(90deg);
    }

    .help-nav-section.collapsed .help-nav-items {
      display: none;
    }

    .help-nav-section.expanded .help-nav-items {
      display: block;
    }

    .help-nav-items {
      list-style: none;
      padding: 0;
      margin: 6px 0 0;
    }

    .help-nav-items a {
      display: block;
      padding: 6px 10px;
      border-radius: 12px;
      color: var(--muted);
      font-size: 18px;
      text-decoration: none;
    }

    .help-nav a:hover {
      background: rgba(15, 23, 42, 0.06);
    }

    .help-nav a[aria-current="page"] {
      color: var(--accent);
      font-weight: 700;
    }

    .help-nav a:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .help-nav-mobile {
      display: none;
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 12px 14px;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(12px);
      box-shadow: 0 4px 12px rgba(15, 23, 42, 0.1);
      margin: 0 16px;
    }

    /* Hide sticky nav on mobile - we use the FAB instead */
    @media (min-width: 391px) and (max-width: 767px) {
      .help-nav-mobile {
        display: none;
      }
    }

    /* Hide mobile nav on desktop (handled by .help-nav instead) */
    @media (min-width: 768px) {
      .help-nav-mobile {
        display: none;
      }
    }

    .help-nav-mobile summary {
      cursor: pointer;
      font-weight: 700;
      color: var(--ink);
    }

    .help-nav-mobile .help-nav-items a {
      padding: 8px 10px;
    }

    /* Floating button for very small screens */
    .help-nav-fab {
      display: none;
      position: fixed;
      bottom: 24px;
      right: 16px;
      z-index: 20;
    }

    /* Show floating button only on very small screens */
    /* Show floating button on mobile screens (up to 767px) */
    @media (max-width: 767px) {
      .help-nav-fab {
        display: block;
      }
    }

    /* Ensure floating button is hidden on larger screens */
    @media (min-width: 768px) {
      .help-nav-fab {
        display: none;
      }
    }

    .help-nav-fab summary {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px 20px;
      border-radius: 9999px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(12px);
      box-shadow: 0 8px 24px rgba(15, 23, 42, 0.2);
      cursor: pointer;
      font-weight: 700;
      font-size: 14px;
      color: var(--ink);
      transition: transform 150ms ease, box-shadow 150ms ease;
      list-style: none;
    }

    .help-nav-fab summary::-webkit-details-marker {
      display: none;
    }

    .help-nav-fab summary:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 32px rgba(15, 23, 42, 0.25);
    }

    .help-nav-fab summary svg {
      width: 16px;
      height: 16px;
    }

    .help-nav-fab[open] summary {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    .help-nav-fab-panel {
      position: fixed;
      bottom: 88px;
      right: 16px;
      left: 16px;
      max-height: 60vh;
      overflow-y: auto;
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 16px;
      background: rgba(255, 255, 255, 0.98);
      backdrop-filter: blur(12px);
      box-shadow: 0 12px 32px rgba(15, 23, 42, 0.2);
    }

    .help-nav-fab-panel .help-nav-search {
      margin-bottom: 12px;
      position: relative;
    }

    .help-nav-fab-panel .help-nav-search input {
      width: 100%;
      padding: 10px 32px 10px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 14px;
      background: white;
      transition: border-color 150ms ease;
    }

    .help-nav-fab-panel .help-nav-search input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .help-nav-fab-panel .help-nav-items {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .help-nav-fab-panel .help-nav-items a {
      display: block;
      padding: 10px 12px;
      border-radius: 12px;
      color: var(--muted);
      font-size: 14px;
      text-decoration: none;
      transition: background 150ms ease;
    }

    .help-nav-fab-panel .help-nav-items a:hover {
      background: rgba(15, 23, 42, 0.06);
    }

    .help-article {
      max-width: 750px;
    }

    .help-article h2,
    .help-article h3 {
      scroll-margin-top: 120px;
    }

    @media (prefers-color-scheme: dark) {
      :root:not(.theme-dark) {
        color-scheme: dark;
        --bg: #0b1220;
        --border: #1f2937;
        --ink: #e5e7eb;
        --muted: #cbd5e1;
        --accent: #38bdf8;
      }
    }

    .theme-dark {
      color-scheme: dark;
      --bg: #0b1220;
      --border: #1f2937;
      --ink: #e5e7eb;
      --muted: #cbd5e1;
      --accent: #38bdf8;
    }

    .theme-dark .help-nav-search input {
      background: #ffffff;
      border-color: #1f2937;
      color: var(--ink);
    }

    .theme-dark .help-nav-search-clear {
      color: #94a3b8;
    }

    .theme-dark .help-nav-search-clear:hover {
      color: #e5e7eb;
    }

    .theme-dark .help-nav-content::-webkit-scrollbar-thumb {
      background: #1f2937;
    }

    .theme-dark .help-nav-content::-webkit-scrollbar-thumb:hover {
      background: #334155;
    }

    .theme-dark .help-nav-toggle:hover {
      background: rgba(255, 255, 255, 0.08);
      color: #e5e7eb;
    }

    .theme-dark .help-nav-fab summary {
      background: rgba(15, 23, 42, 0.95);
      border-color: rgba(255, 255, 255, 0.12);
      color: #e5e7eb;
    }

    .theme-dark .help-nav-fab[open] summary {
      background: var(--accent);
      color: #0b1220;
      border-color: var(--accent);
    }

    .theme-dark .help-nav-fab-panel {
      background: rgba(15, 23, 42, 0.98);
      border-color: #1f2937;
    }

    .theme-dark .help-nav-fab-panel .help-nav-search input {
      background: rgba(15, 23, 42, 0.8);
      border-color: #1f2937;
      color: #e5e7eb;
    }

    .theme-dark .help-nav-fab-panel .help-nav-search input::placeholder {
      color: #94a3b8;
    }

    .theme-dark .help-nav-fab-panel .help-nav-items a:hover {
      background: rgba(255, 255, 255, 0.08);
    }

    .theme-dark .help-nav-mobile {
      background: rgba(15, 23, 42, 0.9);
      border-color: rgba(255, 255, 255, 0.12);
    }

    /* Support article images: add spacing only (no frame) */
    .help-article img {
      display: block;
      max-width: 100%;
      height: auto;
      margin: 18px auto;
      cursor: zoom-in;
      /* Subtle 3D “card” effect (no border/padding) */
      transform: perspective(1200px) rotateX(1.2deg) rotateY(-1.2deg) translateZ(0);
      box-shadow:
        0 18px 40px rgba(15, 23, 42, 0.16),
        0 6px 14px rgba(15, 23, 42, 0.08);
      border-radius: 14px;
      transition: transform 180ms ease, box-shadow 180ms ease;
    }

    @media (min-width: 768px) {
      .help-article img {
        margin: 24px auto;
      }
    }

    @media (hover: hover) and (pointer: fine) {
      .help-article img:hover {
        transform: perspective(1200px) rotateX(0.6deg) rotateY(-0.6deg) translateY(-2px);
        box-shadow:
          0 26px 60px rgba(15, 23, 42, 0.18),
          0 10px 22px rgba(15, 23, 42, 0.10);
      }
    }

    .theme-dark .help-article img {
      box-shadow:
        0 18px 44px rgba(0, 0, 0, 0.42),
        0 8px 18px rgba(0, 0, 0, 0.28);
    }

    /* Image lightbox (Support-only) */
    .image-lightbox {
      border: none;
      padding: 0;
      background: transparent;
      max-width: min(96vw, 1100px);
      max-height: 92vh;
    }

    .image-lightbox::backdrop {
      background: rgba(0, 0, 0, 0.75);
    }

    .image-lightbox img {
      display: block;
      max-width: 96vw;
      max-height: 92vh;
      border-radius: 14px;
      background: transparent;
    }

    .image-lightbox-close {
      position: fixed;
      top: 16px;
      right: 16px;
      width: 44px;
      height: 44px;
      border-radius: 9999px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(15, 23, 42, 0.75);
      color: white;
      font-size: 24px;
      line-height: 1;
      cursor: pointer;
    }
  </style>

  <div class="page">
    <main>
      <div class="help-layout">
        <aside>
          <nav class="help-nav" aria-label="Support navigation">
            <div class="help-nav-search">
              <input type="search" id="help-search" placeholder="Search..." aria-label="Search help articles" />
              <button class="help-nav-search-clear" id="help-search-clear" aria-label="Clear search" type="button">×</button>
            </div>
            <div class="help-nav-content">
              {sections.map((s) => (
                <div class="help-nav-section expanded" data-section={s.id}>
                  <div class="help-nav-section-header">
                    <a href={`#${s.id}`}>{s.title}</a>
                    <button class="help-nav-toggle" aria-label="Toggle section" aria-expanded="true" type="button">
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
                      </svg>
                    </button>
                  </div>
                  {s.items.length > 0 && (
                    <ul class="help-nav-items">
                      {s.items.map((item) => (
                        <li><a href={`#${item.id}`}>{item.title}</a></li>
                      ))}
                    </ul>
                  )}
                </div>
              ))}
            </div>
          </nav>
        </aside>

        <article class="help-article">
          {sections.map((s) => (
            <section id={s.id}>
              <Fragment set:html={marked.parse(s.markdown, { renderer })} />
            </section>
          ))}
        </article>
      </div>
    </main>
  </div>

  <!-- Support-only lightbox (used for images inside the article) -->
  <dialog id="image-lightbox" class="image-lightbox" aria-label="Image preview">
    <button class="image-lightbox-close" type="button" aria-label="Close">×</button>
    <img id="image-lightbox-img" alt="" />
  </dialog>

  <script is:inline>
    // Expand/collapse navigation sections + persist state
    (() => {
      const navSections = document.querySelectorAll('.help-nav-section');
      const savedState = localStorage.getItem('help-nav-state');
      // If there is no saved state yet (first visit), expand only the first section.
      const expandedSections = savedState ? JSON.parse(savedState) : [];
      if (!savedState) {
        const firstSectionId = document.querySelector('.help-nav-section')?.dataset?.section;
        if (firstSectionId) expandedSections.push(firstSectionId);
      }

      navSections.forEach(section => {
        const toggle = section.querySelector('.help-nav-toggle');
        const sectionId = section.dataset.section;
        const headerLink = section.querySelector('.help-nav-section-header a');
        if (!toggle || !sectionId) return;

        const persist = () => localStorage.setItem('help-nav-state', JSON.stringify(expandedSections));

        const setExpanded = (targetId) => {
          // Accordion behavior: only one section open at a time
          navSections.forEach((s) => {
            const id = s.dataset.section;
            const t = s.querySelector('.help-nav-toggle');
            const open = id === targetId;
            s.classList.toggle('expanded', open);
            s.classList.toggle('collapsed', !open);
            if (t) t.setAttribute('aria-expanded', open ? 'true' : 'false');
          });

          expandedSections.length = 0;
          if (targetId) expandedSections.push(targetId);
          persist();
        };

        // default: only sections in expandedSections are open
        const isExpanded = expandedSections.includes(sectionId);
        section.classList.toggle('expanded', isExpanded);
        section.classList.toggle('collapsed', !isExpanded);
        toggle.setAttribute('aria-expanded', isExpanded ? 'true' : 'false');

        const toggleSection = (e) => {
          e?.preventDefault?.();
          e?.stopPropagation?.();
          const currentlyExpanded = section.classList.contains('expanded');
          if (currentlyExpanded) {
            setExpanded(null);
          } else {
            setExpanded(sectionId);
          }
        };

        const expandSection = () => {
          if (section.classList.contains('expanded')) return;
          setExpanded(sectionId);
        };

        toggle.addEventListener('click', toggleSection);
        headerLink?.addEventListener('click', () => expandSection());
      });
    })();

    // Search functionality
    (() => {
      const normalize = (s) =>
        (s || '')
          .toString()
          .toLowerCase()
          .replace(/\s+/g, ' ')
          .trim();

      // For a heading anchor (h2/h3), return the full text "block" until the next heading.
      // This makes search match real content, not just nav titles.
      const blockTextCache = new Map();
      const getBlockTextForAnchor = (anchorId) => {
        if (!anchorId) return '';
        if (blockTextCache.has(anchorId)) return blockTextCache.get(anchorId);

        const el = document.getElementById(anchorId);
        if (!el) {
          blockTextCache.set(anchorId, '');
          return '';
        }

        // H2 sections are wrapped in <section id="...">. If the anchor resolves to that wrapper,
        // we must NOT traverse siblings, otherwise we'd accidentally include following sections.
        if (el.tagName === 'SECTION') {
          const out = normalize(el.textContent || '');
          blockTextCache.set(anchorId, out);
          return out;
        }

        const stopAt = el.tagName === 'H2' ? new Set(['H2']) : new Set(['H2', 'H3']);
        let text = el.textContent || '';
        let node = el.nextElementSibling;
        while (node) {
          if (stopAt.has(node.tagName)) break;
          text += ` ${node.textContent || ''}`;
          node = node.nextElementSibling;
        }

        const out = normalize(text);
        blockTextCache.set(anchorId, out);
        return out;
      };

      const searchInput = document.getElementById('help-search');
      const searchClear = document.getElementById('help-search-clear');
      const allNavItems = document.querySelectorAll('.help-nav-items li');
      const allNavSections = document.querySelectorAll('.help-nav-section');
      if (!searchInput) return;

      const updateClearButton = () => {
        if (searchClear) {
          searchClear.classList.toggle('visible', searchInput.value.length > 0);
        }
      };

      searchInput.addEventListener('input', (e) => {
        updateClearButton();
        const query = normalize(e.target.value || '');
        if (query === '') {
          allNavItems.forEach(item => item.classList.remove('hidden-by-search', 'highlight-match'));
          allNavSections.forEach(section => section.classList.remove('hidden-by-search'));
          return;
        }

        let hasMatches = false;
        allNavItems.forEach(item => {
          const link = item.querySelector('a');
          const text = normalize(link ? link.textContent : '');
          const href = link ? (link.getAttribute('href') || '') : '';
          const anchorId = href.startsWith('#') ? href.slice(1) : '';
          const blockText = getBlockTextForAnchor(anchorId);

          if (text.includes(query) || normalize(href).includes(query) || blockText.includes(query)) {
            item.classList.remove('hidden-by-search');
            item.classList.add('highlight-match');
            hasMatches = true;

            const parentSection = item.closest('.help-nav-section');
            if (parentSection) {
              parentSection.classList.remove('hidden-by-search', 'collapsed');
              parentSection.classList.add('expanded');
              const toggle = parentSection.querySelector('.help-nav-toggle');
              if (toggle) toggle.setAttribute('aria-expanded', 'true');
            }
          } else {
            item.classList.remove('highlight-match');
            item.classList.add('hidden-by-search');
          }
        });

        allNavSections.forEach(section => {
          const items = section.querySelectorAll('.help-nav-items li');
          const visibleItems = Array.from(items).filter(item => !item.classList.contains('hidden-by-search'));
          const sectionHeader = section.querySelector('.help-nav-section-header a');
          const sectionText = normalize(sectionHeader ? sectionHeader.textContent : '');
          const sectionHref = sectionHeader ? (sectionHeader.getAttribute('href') || '') : '';
          const sectionAnchorId = sectionHref.startsWith('#') ? sectionHref.slice(1) : '';
          const sectionBlockText = getBlockTextForAnchor(sectionAnchorId);
          if (visibleItems.length > 0 || sectionText.includes(query) || sectionBlockText.includes(query)) {
            section.classList.remove('hidden-by-search');
          }
          else section.classList.add('hidden-by-search');
        });

        if (hasMatches) {
          const firstMatch = document.querySelector('.help-nav-items li.highlight-match a');
          firstMatch?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      });

      if (searchClear) {
        searchClear.addEventListener('click', () => {
          searchInput.value = '';
          searchInput.dispatchEvent(new Event('input'));
          searchInput.focus();
        });
      }

      updateClearButton();
    })();

    // Search functionality for floating navigation (small screens)
    (() => {
      const searchInput = document.getElementById('help-search-fab');
      const searchClear = document.getElementById('help-search-fab-clear');
      if (!searchInput) return;

      const normalize = (s) =>
        (s || '')
          .toString()
          .toLowerCase()
          .replace(/\s+/g, ' ')
          .trim();

      // Same "block text" logic as desktop search: from heading to next heading.
      const blockTextCache = new Map();
      const getBlockTextForAnchor = (anchorId) => {
        if (!anchorId) return '';
        if (blockTextCache.has(anchorId)) return blockTextCache.get(anchorId);

        const el = document.getElementById(anchorId);
        if (!el) {
          blockTextCache.set(anchorId, '');
          return '';
        }

        // H2 sections are wrapped in <section id="...">. Treat wrapper as boundary.
        if (el.tagName === 'SECTION') {
          const out = normalize(el.textContent || '');
          blockTextCache.set(anchorId, out);
          return out;
        }

        const stopAt = el.tagName === 'H2' ? new Set(['H2']) : new Set(['H2', 'H3']);
        let text = el.textContent || '';
        let node = el.nextElementSibling;
        while (node) {
          if (stopAt.has(node.tagName)) break;
          text += ` ${node.textContent || ''}`;
          node = node.nextElementSibling;
        }

        const out = normalize(text);
        blockTextCache.set(anchorId, out);
        return out;
      };

      const updateClearButton = () => {
        if (searchClear) {
          searchClear.classList.toggle('visible', searchInput.value.length > 0);
        }
      };

      searchInput.addEventListener('input', (e) => {
        updateClearButton();
        const query = normalize(e.target.value || '');
        const fabPanel = document.querySelector('.help-nav-fab-panel');
        const allNavItems = fabPanel ? fabPanel.querySelectorAll('.help-nav-items li') : [];
        const allNavSections = fabPanel ? fabPanel.querySelectorAll('.help-nav-section') : [];
        
        if (query === '') {
          allNavItems.forEach(item => item.style.display = '');
          allNavSections.forEach(section => section.style.display = '');
          return;
        }

        allNavItems.forEach(item => {
          const link = item.querySelector('a');
          if (!link) {
            item.style.display = 'none';
            return;
          }
          
          // Get the anchor ID from the link's href
          const anchorId = link.getAttribute('href')?.replace('#', '') || '';
          const linkText = normalize(link.textContent || '');
          const blockText = getBlockTextForAnchor(anchorId);
          
          if (linkText.includes(query) || blockText.includes(query)) {
            item.style.display = '';
          } else {
            item.style.display = 'none';
          }
        });

        // Hide empty sections (but keep sections whose own body matches query)
        allNavSections.forEach(section => {
          const sectionHeader = section.querySelector('.help-nav-section-header a');
          const sectionHref = sectionHeader ? (sectionHeader.getAttribute('href') || '') : '';
          const sectionAnchorId = sectionHref.startsWith('#') ? sectionHref.slice(1) : '';
          const sectionBlockText = getBlockTextForAnchor(sectionAnchorId);

          const items = section.querySelectorAll('.help-nav-items li');
          const visibleItems = Array.from(items).filter((li) => li.style.display !== 'none');

          if (visibleItems.length > 0 || sectionBlockText.includes(query)) {
            section.style.display = '';
          } else {
            section.style.display = 'none';
          }
        });
      });

      if (searchClear) {
        searchClear.addEventListener('click', () => {
          searchInput.value = '';
          searchInput.dispatchEvent(new Event('input'));
          searchInput.focus();
        });
      }

      updateClearButton();
    })();

    // Image lightbox for images inside the Support article
    (() => {
      const dialog = document.getElementById('image-lightbox');
      const dialogImg = document.getElementById('image-lightbox-img');
      const closeBtn = document.querySelector('.image-lightbox-close');

      if (!dialog || !dialogImg) return;

      const close = () => {
        try {
          dialog.close();
        } catch {
          // no-op
        }
      };

      closeBtn?.addEventListener('click', close);
      dialog.addEventListener('click', (e) => {
        if (e.target === dialog) close();
      });

      document.addEventListener('click', (e) => {
        const target = e.target instanceof Element ? e.target : null;
        const img = target?.closest?.('.help-article img');
        if (!img) return;

        const src = img.currentSrc || img.getAttribute('src') || '';
        if (!src) return;

        dialogImg.src = src;
        dialogImg.alt = img.getAttribute('alt') || '';

        if (typeof dialog.showModal === 'function') {
          dialog.showModal();
        }
      });
    })();

    // Theme-aware screenshots inside Support markdown:
    // Use <img class="support-theme-image" data-light="/...-light.png" data-dark="/...-dark.png" ... />
    (() => {
      const root = document.documentElement;

      const applyThemeImages = () => {
        const isDark = root.classList.contains('theme-dark');
        document.querySelectorAll('img.support-theme-image').forEach((img) => {
          // Attach a one-time error handler to fall back to light if dark is missing.
          if (!img.dataset.themeFallbackInit) {
            img.dataset.themeFallbackInit = '1';
            img.addEventListener('error', () => {
              const desired = img.dataset.desiredTheme || '';
              if (desired !== 'dark') return;
              if (!img.dataset.light) return;
              // Mark dark as missing for this session to avoid retry loops.
              img.dataset.darkMissing = '1';
              if (img.getAttribute('src') !== img.dataset.light) {
                img.setAttribute('src', img.dataset.light);
              }
            });
          }

          // If dark is missing, keep using light even in dark mode.
          const next = (isDark && img.dataset.darkMissing !== '1') ? img.dataset.dark : img.dataset.light;
          if (!next) return;
          img.dataset.desiredTheme = isDark ? 'dark' : 'light';
          if (img.getAttribute('src') !== next) img.setAttribute('src', next);
        });
      };

      applyThemeImages();

      const obs = new MutationObserver(() => applyThemeImages());
      obs.observe(root, { attributes: true, attributeFilter: ['class'] });
    })();

    // Highlight active section (based on scroll position)
    (() => {
      const anchorKey = `help-scroll-anchor:${location.pathname}`;
      const scrollKey = `help-scroll-y:${location.pathname}`;
      // Use manual scroll restoration so the browser doesn't fight our saved position.
      try {
        if ('scrollRestoration' in history) history.scrollRestoration = 'manual';
      } catch {}

      const scrollToSection = (id) => {
        const safeId = String(id || '').replace(/^#/, '');
        if (!safeId) return false;
        const target = document.getElementById(safeId);
        if (!target) return false;
        const offsetTop = target.offsetTop - 120;
        window.scrollTo({ top: offsetTop, behavior: 'auto' });
        return true;
      };

      const restoreExactScroll = () => {
        if (location.hash) return;
        let savedY = null;
        try {
          const raw = localStorage.getItem(scrollKey);
          if (raw != null) {
            const parsed = parseInt(raw, 10);
            if (!Number.isNaN(parsed) && parsed >= 0) savedY = parsed;
          }
        } catch {}
        if (savedY == null) return;

        // Try a few times in case fonts/layout shift after first paint.
        let attempts = 0;
        const maxAttempts = 20;
        const tick = () => {
          attempts += 1;
          window.scrollTo({ top: savedY, behavior: 'auto' });
          if (Math.abs(window.scrollY - savedY) < 2) return;
          if (attempts >= maxAttempts) return;
          setTimeout(tick, 50);
        };

        requestAnimationFrame(() => {
          tick();
        });
      };

      // Persist exact scroll position (throttled)
      let saveTimer;
      const saveScrollY = () => {
        clearTimeout(saveTimer);
        saveTimer = setTimeout(() => {
          try {
            localStorage.setItem(scrollKey, String(window.scrollY));
          } catch {}
        }, 100);
      };

      const updateActiveSection = () => {
        const pageSections = document.querySelectorAll('.help-article section[id]');
        const navLinks = document.querySelectorAll('.help-nav-section-header a, .help-nav-items a');
        navLinks.forEach(link => link.removeAttribute('aria-current'));

        const scrollPos = window.scrollY + 150;
        let activeSection = null;
        pageSections.forEach(section => {
          const top = section.offsetTop;
          const height = section.offsetHeight;
          if (scrollPos >= top && scrollPos < top + height) activeSection = section.id;
        });

        if (!activeSection && window.scrollY < 200) activeSection = pageSections[0]?.id;
        if (activeSection) {
          const mainLink = document.querySelector(`.help-nav-section-header a[href="#${activeSection}"]`);
          mainLink?.setAttribute('aria-current', 'page');

          // Persist last viewed section so we can restore scroll position on revisit.
          try {
            localStorage.setItem(anchorKey, activeSection);
          } catch {}
        }
      };

      let scrollTimeout;
      window.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(updateActiveSection, 100);
        saveScrollY();
      });

      // Restore exact scroll position on revisit (unless URL already has a hash).
      // Run once early and again after full load (handles font/layout shifts).
      restoreExactScroll();
      window.addEventListener('load', restoreExactScroll, { once: true });
      if (document.fonts?.ready) {
        document.fonts.ready.then(() => restoreExactScroll()).catch(() => {});
      }

      updateActiveSection();

      // Smooth scroll for anchors
      document.querySelectorAll('a[href^=\"#\"]').forEach(anchor => {
        anchor.addEventListener('click', function (e) {
          const href = this.getAttribute('href');
          if (!href || href === '#') return;
          const target = document.querySelector(href);
          if (target) {
            e.preventDefault();
            const offsetTop = target.offsetTop - 120;
            window.scrollTo({ top: offsetTop, behavior: 'smooth' });
            // Also persist the anchor right away.
            try {
              localStorage.setItem(anchorKey, href.replace('#', ''));
            } catch {}
            saveScrollY();
            setTimeout(updateActiveSection, 500);
          }
        });
      });
    })();
  </script>
</BaseLayout>
