---
import BaseLayout from '../../layouts/BaseLayout.astro';
import { SUPPORTED_LANGS, DEFAULT_LANG, isValidLanguage } from '../../utils/i18n';
import { generateFallbackDescription } from '../../utils/seo';
import { readFileSync, existsSync } from 'fs';
import { join } from 'path';
import { marked } from 'marked';

export function getStaticPaths() {
  return SUPPORTED_LANGS.map(lang => ({
    params: { lang }
  }));
}

const { lang } = Astro.params;

if (!isValidLanguage(lang)) {
  return Astro.redirect(`/${DEFAULT_LANG}/support`);
}

function slugify(input: string): string {
  return input
    .toLowerCase()
    .trim()
    .replace(/[^\p{L}\p{N}\s-]/gu, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-');
}

// Load markdown content
const contentPath = join(process.cwd(), 'content', 'pages', lang, 'support.md');
let rawMarkdown = '';
let title = 'Support Â· Vokabulo';
let description = '';
type SupportSection = { id: string; title: string; items: { id: string; title: string }[]; markdown: string };
let sections: SupportSection[] = [];

if (existsSync(contentPath)) {
  const fileContent = readFileSync(contentPath, 'utf-8');
  // Extract frontmatter
  const frontmatterMatch = fileContent.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
  if (frontmatterMatch) {
    const frontmatter = frontmatterMatch[1];
    rawMarkdown = frontmatterMatch[2];
    const titleMatch = frontmatter.match(/title:\s*["'](.*)["']/);
    if (titleMatch) title = titleMatch[1];
    const descMatch = frontmatter.match(/description:\s*["'](.*)["']/);
    if (descMatch) description = descMatch[1];
  } else {
    rawMarkdown = fileContent;
  }
  
  // Generate fallback description if not in frontmatter
  if (!description && rawMarkdown) {
    description = generateFallbackDescription(rawMarkdown, 160);
  }
}

// Split markdown into H2 sections while keeping the page as one continuous document.
// H2 (##) => sidebar section, H3 (###) => subsection link under that section.
(() => {
  const lines = rawMarkdown.split('\n');
  let current: SupportSection | null = null;
  let buffer: string[] = [];

  const flush = () => {
    if (!current) return;
    current.markdown = buffer.join('\n').trim() + '\n';
    sections.push(current);
  };

  for (const line of lines) {
    const h2 = line.match(/^##\s+(.*)\s*$/);
    if (h2) {
      flush();
      const h2Title = h2[1].trim();
      const h2Id = slugify(h2Title);
      current = { id: h2Id, title: h2Title, items: [], markdown: '' };
      buffer = [line];
      continue;
    }

    const h3 = line.match(/^###\s+(.*)\s*$/);
    if (h3 && current) {
      const h3Title = h3[1].trim();
      const h3Id = slugify(h3Title);
      current.items.push({ id: h3Id, title: h3Title });
    }

    buffer.push(line);
  }

  flush();
})();

// Render markdown with stable heading ids (needed for anchor nav)
// Note: marked v17 passes a token object to renderer.heading().
const renderer = new marked.Renderer();
// eslint-disable-next-line @typescript-eslint/no-explicit-any
renderer.heading = (...args: any[]) => {
  // marked v17: heading(token)
  if (args.length === 1 && typeof args[0] === 'object' && args[0]) {
    const token = args[0];
    const level = token.depth ?? token.level ?? token.depthLevel ?? 0;
    const text = String(token.text ?? '');
    if (level === 2 || level === 3) {
      const id = slugify(text);
      return `<h${level} id="${id}">${text}</h${level}>`;
    }
    return `<h${level}>${text}</h${level}>`;
  }

  // older marked: heading(text, level, raw)
  const [text, level, raw] = args;
  const headingText = String(text ?? '');
  const headingLevel = Number(level ?? 0);
  if (headingLevel === 2 || headingLevel === 3) {
    const id = slugify(String(raw ?? headingText));
    return `<h${headingLevel} id="${id}">${headingText}</h${headingLevel}>`;
  }
  return `<h${headingLevel}>${headingText}</h${headingLevel}>`;
};
---

<BaseLayout title={title} description={description} currentLang={lang} currentPath="/support">
  <style is:global>
    /* Support page-specific styles */
    :root {
      --accent: #0ea5e9;
    }

    .page {
      max-width: 1100px;
      margin: 0 auto;
      padding: 16px 16px 48px;
    }

    main {
      padding: 48px 40px;
      padding-top: 140px;
    }

    h1 {
      margin: 0 0 24px;
      font-size: 40px;
      font-weight: 700;
      line-height: 1.2;
      letter-spacing: -0.02em;
    }

    h2 {
      margin: 48px 0 16px;
      font-size: 28px;
      font-weight: 700;
      line-height: 1.3;
      color: var(--ink);
      letter-spacing: -0.01em;
      padding-top: 20px;
      border-top: 1px solid var(--border);
    }

    h2:first-of-type {
      margin-top: 0;
      padding-top: 0;
      border-top: none;
    }

    h3 {
      margin: 40px 0 16px;
      font-size: 20px;
      font-weight: 600;
      line-height: 1.4;
      color: var(--ink);
      letter-spacing: -0.01em;
      scroll-margin-top: 100px;
    }

    p {
      margin: 0 0 20px;
      color: var(--muted);
      line-height: 1.7;
      font-size: 16px;
    }

    /* Only apply list typography spacing to the article content.
       The left nav also uses <ul>/<li>, and we don't want big gaps there. */
    .help-article ul {
      padding-left: 24px;
      margin: 0 0 20px;
      color: var(--muted);
      line-height: 1.7;
      font-size: 16px;
    }

    .help-article ul li {
      margin: 0 0 12px;
    }

    .help-article ul li strong {
      color: var(--ink);
      font-weight: 600;
    }

    strong {
      color: var(--ink);
      font-weight: 600;
    }

    hr {
      border: none;
      border-top: 1px solid var(--border);
      margin: 32px 0;
    }

    /* Support page (Notion-like) layout (from original support.html) */
    .help-layout {
      display: grid;
      grid-template-columns: 1fr;
      gap: 22px;
    }

    @media (min-width: 768px) {
      .help-layout {
        grid-template-columns: 280px 1fr;
        gap: 28px;
      }
    }

    .help-nav {
      display: none;
    }

    @media (min-width: 768px) {
      .help-nav {
        display: flex;
        flex-direction: column;
        position: sticky;
        top: 120px;
        align-self: start;
        border-right: 1px solid var(--border);
        padding-right: 18px;
        margin-right: 6px;
        max-height: calc(100vh - 140px);
        overflow-y: auto;
      }
    }

    .help-nav-search {
      margin-bottom: 16px;
    }

    .help-nav-search input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #ffffff;
      color: var(--ink);
      font-size: 14px;
      transition: border-color 150ms ease, box-shadow 150ms ease;
    }

    .help-nav-search input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);
    }

    .help-nav-section.hidden-by-search,
    .help-nav-items li.hidden-by-search {
      display: none;
    }

    .help-nav-items li.highlight-match a {
      color: var(--accent);
      font-weight: 600;
    }

    .help-nav-content {
      flex: 1;
      overflow-y: auto;
      padding-right: 4px;
    }

    .help-nav-content::-webkit-scrollbar {
      width: 6px;
    }

    .help-nav-content::-webkit-scrollbar-track {
      background: transparent;
    }

    .help-nav-content::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 3px;
    }

    .help-nav-content::-webkit-scrollbar-thumb:hover {
      background: var(--muted);
    }

    .help-nav-section {
      margin: 0 0 16px;
    }

    .help-nav-section-header {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      user-select: none;
    }

    .help-nav-section-header a {
      flex: 1;
      display: block;
      padding: 6px 10px;
      border-radius: 12px;
      font-weight: 700;
      color: var(--ink);
      text-decoration: none;
    }

    .help-nav-section-header:hover a {
      background: rgba(15, 23, 42, 0.06);
    }

    .help-nav-toggle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      padding: 0;
      border: none;
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      transition: transform 200ms ease, color 150ms ease;
      flex-shrink: 0;
      border-radius: 4px;
    }

    .help-nav-toggle:hover {
      color: var(--ink);
      background: rgba(15, 23, 42, 0.06);
    }

    .help-nav-toggle svg {
      width: 14px;
      height: 14px;
    }

    .help-nav-section.expanded .help-nav-toggle {
      transform: rotate(90deg);
    }

    .help-nav-section.collapsed .help-nav-items {
      display: none;
    }

    .help-nav-section.expanded .help-nav-items {
      display: block;
    }

    .help-nav-items {
      list-style: none;
      padding: 0;
      margin: 6px 0 0;
    }

    .help-nav-items a {
      display: block;
      padding: 6px 10px;
      border-radius: 12px;
      color: var(--muted);
      font-size: 14px;
      text-decoration: none;
    }

    .help-nav a:hover {
      background: rgba(15, 23, 42, 0.06);
    }

    .help-nav a[aria-current="page"] {
      color: var(--accent);
      font-weight: 700;
    }

    .help-nav a:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .help-nav-mobile {
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 12px 14px;
      background: rgba(255, 255, 255, 0.7);
    }

    .help-nav-mobile summary {
      cursor: pointer;
      font-weight: 700;
      color: var(--ink);
    }

    .help-nav-mobile .help-nav-items a {
      padding: 8px 10px;
    }

    .help-article {
      max-width: 750px;
    }

    .help-article h2,
    .help-article h3 {
      scroll-margin-top: 120px;
    }

    @media (prefers-color-scheme: dark) {
      :root:not(.theme-dark) {
        color-scheme: dark;
        --bg: #0b1220;
        --border: #1f2937;
        --ink: #e5e7eb;
        --muted: #cbd5e1;
        --accent: #38bdf8;
      }
    }

    .theme-dark {
      color-scheme: dark;
      --bg: #0b1220;
      --border: #1f2937;
      --ink: #e5e7eb;
      --muted: #cbd5e1;
      --accent: #38bdf8;
    }

    .theme-dark .help-nav-search input {
      background: #ffffff;
      border-color: #1f2937;
      color: var(--ink);
    }

    .theme-dark .help-nav-content::-webkit-scrollbar-thumb {
      background: #1f2937;
    }

    .theme-dark .help-nav-content::-webkit-scrollbar-thumb:hover {
      background: #334155;
    }

    .theme-dark .help-nav-toggle:hover {
      background: rgba(255, 255, 255, 0.08);
      color: #e5e7eb;
    }
  </style>

  <div class="page">
    <main>
      <div class="help-layout">
        <aside>
          <details class="help-nav-mobile md:hidden">
            <summary>On this page</summary>
            <nav aria-label="Support navigation (mobile)">
              <ul class="help-nav-items">
                {sections.map((s) => (
                  <li><a href={`#${s.id}`}>{s.title}</a></li>
                ))}
              </ul>
            </nav>
          </details>

          <nav class="help-nav" aria-label="Support navigation">
            <div class="help-nav-search">
              <input type="search" id="help-search" placeholder="Search..." aria-label="Search help articles" />
            </div>
            <div class="help-nav-content">
              {sections.map((s) => (
                <div class="help-nav-section expanded" data-section={s.id}>
                  <div class="help-nav-section-header">
                    <a href={`#${s.id}`}>{s.title}</a>
                    <button class="help-nav-toggle" aria-label="Toggle section" aria-expanded="true" type="button">
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
                      </svg>
                    </button>
                  </div>
                  {s.items.length > 0 && (
                    <ul class="help-nav-items">
                      {s.items.map((item) => (
                        <li><a href={`#${item.id}`}>{item.title}</a></li>
                      ))}
                    </ul>
                  )}
                </div>
              ))}
            </div>
          </nav>
        </aside>

        <article class="help-article">
          {sections.map((s) => (
            <section id={s.id}>
              <Fragment set:html={marked.parse(s.markdown, { renderer })} />
            </section>
          ))}
        </article>
      </div>
    </main>
  </div>

  <script is:inline>
    // Expand/collapse navigation sections + persist state
    (() => {
      const navSections = document.querySelectorAll('.help-nav-section');
      const savedState = localStorage.getItem('help-nav-state');
      // If there is no saved state yet (first visit), expand only the first section.
      const expandedSections = savedState ? JSON.parse(savedState) : [];
      if (!savedState) {
        const firstSectionId = document.querySelector('.help-nav-section')?.dataset?.section;
        if (firstSectionId) expandedSections.push(firstSectionId);
      }

      navSections.forEach(section => {
        const toggle = section.querySelector('.help-nav-toggle');
        const sectionId = section.dataset.section;
        const headerLink = section.querySelector('.help-nav-section-header a');
        if (!toggle || !sectionId) return;

        // default: only sections in expandedSections are open
        const isExpanded = expandedSections.includes(sectionId);
        section.classList.toggle('expanded', isExpanded);
        section.classList.toggle('collapsed', !isExpanded);
        toggle.setAttribute('aria-expanded', isExpanded ? 'true' : 'false');

        const persist = () => localStorage.setItem('help-nav-state', JSON.stringify(expandedSections));

        const toggleSection = (e) => {
          e?.preventDefault?.();
          e?.stopPropagation?.();
          const currentlyExpanded = section.classList.contains('expanded');
          if (currentlyExpanded) {
            section.classList.remove('expanded');
            section.classList.add('collapsed');
            toggle.setAttribute('aria-expanded', 'false');
            const idx = expandedSections.indexOf(sectionId);
            if (idx !== -1) expandedSections.splice(idx, 1);
          } else {
            section.classList.remove('collapsed');
            section.classList.add('expanded');
            toggle.setAttribute('aria-expanded', 'true');
            if (!expandedSections.includes(sectionId)) expandedSections.push(sectionId);
          }
          persist();
        };

        const expandSection = () => {
          if (section.classList.contains('expanded')) return;
          section.classList.remove('collapsed');
          section.classList.add('expanded');
          toggle.setAttribute('aria-expanded', 'true');
          if (!expandedSections.includes(sectionId)) expandedSections.push(sectionId);
          persist();
        };

        toggle.addEventListener('click', toggleSection);
        headerLink?.addEventListener('click', () => expandSection());
      });
    })();

    // Search functionality
    (() => {
      const searchInput = document.getElementById('help-search');
      const allNavItems = document.querySelectorAll('.help-nav-items li');
      const allNavSections = document.querySelectorAll('.help-nav-section');
      if (!searchInput) return;

      searchInput.addEventListener('input', (e) => {
        const query = (e.target.value || '').toLowerCase().trim();
        if (query === '') {
          allNavItems.forEach(item => item.classList.remove('hidden-by-search', 'highlight-match'));
          allNavSections.forEach(section => section.classList.remove('hidden-by-search'));
          return;
        }

        let hasMatches = false;
        allNavItems.forEach(item => {
          const link = item.querySelector('a');
          const text = link ? link.textContent.toLowerCase() : '';
          const href = link ? link.getAttribute('href') : '';

          if (text.includes(query) || (href && href.toLowerCase().includes(query))) {
            item.classList.remove('hidden-by-search');
            item.classList.add('highlight-match');
            hasMatches = true;

            const parentSection = item.closest('.help-nav-section');
            if (parentSection) {
              parentSection.classList.remove('hidden-by-search', 'collapsed');
              parentSection.classList.add('expanded');
              const toggle = parentSection.querySelector('.help-nav-toggle');
              if (toggle) toggle.setAttribute('aria-expanded', 'true');
            }
          } else {
            item.classList.remove('highlight-match');
            item.classList.add('hidden-by-search');
          }
        });

        allNavSections.forEach(section => {
          const items = section.querySelectorAll('.help-nav-items li');
          const visibleItems = Array.from(items).filter(item => !item.classList.contains('hidden-by-search'));
          const sectionHeader = section.querySelector('.help-nav-section-header a');
          const sectionText = sectionHeader ? sectionHeader.textContent.toLowerCase() : '';
          if (visibleItems.length > 0 || sectionText.includes(query)) section.classList.remove('hidden-by-search');
          else section.classList.add('hidden-by-search');
        });

        if (hasMatches) {
          const firstMatch = document.querySelector('.help-nav-items li.highlight-match a');
          firstMatch?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      });
    })();

    // Highlight active section (based on scroll position)
    (() => {
      const anchorKey = `help-scroll-anchor:${location.pathname}`;
      const scrollKey = `help-scroll-y:${location.pathname}`;
      // Use manual scroll restoration so the browser doesn't fight our saved position.
      try {
        if ('scrollRestoration' in history) history.scrollRestoration = 'manual';
      } catch {}

      const scrollToSection = (id) => {
        const safeId = String(id || '').replace(/^#/, '');
        if (!safeId) return false;
        const target = document.getElementById(safeId);
        if (!target) return false;
        const offsetTop = target.offsetTop - 120;
        window.scrollTo({ top: offsetTop, behavior: 'auto' });
        return true;
      };

      const restoreExactScroll = () => {
        if (location.hash) return;
        let savedY = null;
        try {
          const raw = localStorage.getItem(scrollKey);
          if (raw != null) {
            const parsed = parseInt(raw, 10);
            if (!Number.isNaN(parsed) && parsed >= 0) savedY = parsed;
          }
        } catch {}
        if (savedY == null) return;

        // Try a few times in case fonts/layout shift after first paint.
        let attempts = 0;
        const maxAttempts = 20;
        const tick = () => {
          attempts += 1;
          window.scrollTo({ top: savedY, behavior: 'auto' });
          if (Math.abs(window.scrollY - savedY) < 2) return;
          if (attempts >= maxAttempts) return;
          setTimeout(tick, 50);
        };

        requestAnimationFrame(() => {
          tick();
        });
      };

      // Persist exact scroll position (throttled)
      let saveTimer;
      const saveScrollY = () => {
        clearTimeout(saveTimer);
        saveTimer = setTimeout(() => {
          try {
            localStorage.setItem(scrollKey, String(window.scrollY));
          } catch {}
        }, 100);
      };

      const updateActiveSection = () => {
        const pageSections = document.querySelectorAll('.help-article section[id]');
        const navLinks = document.querySelectorAll('.help-nav-section-header a, .help-nav-items a');
        navLinks.forEach(link => link.removeAttribute('aria-current'));

        const scrollPos = window.scrollY + 150;
        let activeSection = null;
        pageSections.forEach(section => {
          const top = section.offsetTop;
          const height = section.offsetHeight;
          if (scrollPos >= top && scrollPos < top + height) activeSection = section.id;
        });

        if (!activeSection && window.scrollY < 200) activeSection = pageSections[0]?.id;
        if (activeSection) {
          const mainLink = document.querySelector(`.help-nav-section-header a[href="#${activeSection}"]`);
          mainLink?.setAttribute('aria-current', 'page');

          // Persist last viewed section so we can restore scroll position on revisit.
          try {
            localStorage.setItem(anchorKey, activeSection);
          } catch {}
        }
      };

      let scrollTimeout;
      window.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(updateActiveSection, 100);
        saveScrollY();
      });

      // Restore exact scroll position on revisit (unless URL already has a hash).
      // Run once early and again after full load (handles font/layout shifts).
      restoreExactScroll();
      window.addEventListener('load', restoreExactScroll, { once: true });
      if (document.fonts?.ready) {
        document.fonts.ready.then(() => restoreExactScroll()).catch(() => {});
      }

      updateActiveSection();

      // Smooth scroll for anchors
      document.querySelectorAll('a[href^=\"#\"]').forEach(anchor => {
        anchor.addEventListener('click', function (e) {
          const href = this.getAttribute('href');
          if (!href || href === '#') return;
          const target = document.querySelector(href);
          if (target) {
            e.preventDefault();
            const offsetTop = target.offsetTop - 120;
            window.scrollTo({ top: offsetTop, behavior: 'smooth' });
            // Also persist the anchor right away.
            try {
              localStorage.setItem(anchorKey, href.replace('#', ''));
            } catch {}
            saveScrollY();
            setTimeout(updateActiveSection, 500);
          }
        });
      });
    })();
  </script>
</BaseLayout>
